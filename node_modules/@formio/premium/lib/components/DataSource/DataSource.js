var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { Formio, Components } from 'formiojs';
import * as fetchPonyfill from 'fetch-ponyfill';
import * as _ from 'lodash';
import * as NativePromise from 'native-promise-only';
import editForm from './DataSource.form';
var Component = Components.components.component;
var fetch = fetchPonyfill({
    Promise: NativePromise,
}).fetch;
var DataSource = /** @class */ (function (_super) {
    __extends(DataSource, _super);
    function DataSource(component, options, data) {
        return _super.call(this, component, options, data) || this;
    }
    Object.defineProperty(DataSource, "builderInfo", {
        get: function () {
            return {
                title: 'Data Source',
                icon: 'cloud',
                group: 'premium',
                documentation: 'http://help.form.io/userguide/#datasource',
                weight: 30,
                schema: DataSource.schema(),
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "requestHeaders", {
        /**
         * Get the request headers for this select dropdown.
         */
        get: function () {
            var _this = this;
            // Create the headers object.
            var headers = new Formio.Headers();
            // Add custom headers to the url.
            if (this.component.fetch && this.component.fetch.headers) {
                try {
                    this.component.fetch.headers.forEach(function (header) {
                        if (header.key) {
                            headers.set(header.key, _this.interpolate(header.value));
                        }
                    });
                }
                catch (err) {
                    /* tslint:disable */
                    console.warn(err.message);
                    /* tslint:enable */
                }
            }
            if (this.reqMethod === 'POST' && !headers.has('Content-type')) {
                headers.set('Content-type', 'application/json');
            }
            return headers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "reqMethod", {
        get: function () {
            var method = _.get(this.component, 'fetch.method', 'get');
            return method.toUpperCase();
        },
        enumerable: false,
        configurable: true
    });
    DataSource.schema = function () {
        var extend = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            extend[_i] = arguments[_i];
        }
        return Component.schema.apply(Component, __spreadArrays([{
                label: 'Data Source',
                key: 'dataSource',
                type: 'datasource',
                persistent: 'client-only',
            }], extend));
    };
    DataSource.prototype.init = function () {
        if (_.get(this.component, 'trigger.init', false)) {
            this.refresh();
        }
        return _super.prototype.init.call(this);
    };
    DataSource.prototype.render = function () {
        if (this.builderMode) {
            return _super.prototype.render.call(this, this.component.label || 'Data Source');
        }
        // Is there a better way to be hidden on the page?
        return _super.prototype.render.call(this, ' ');
    };
    DataSource.prototype.attach = function (element) {
        return _super.prototype.attach.call(this, element);
    };
    DataSource.prototype.refresh = function (value, changed, flags) {
        var _this = this;
        if (!this.options.readOnly) {
            switch (this.component.dataSrc) {
                case 'url':
                    var body = null;
                    var isBody = !!_.get(this.component, 'fetch.specifyPostBody', '');
                    if (isBody && this.reqMethod === 'POST') {
                        body = this.specifyBody();
                    }
                    var request = Formio.makeStaticRequest(this.interpolate(this.component.fetch.url), this.reqMethod, body, {
                        headers: this.requestHeaders,
                        noToken: !(this.component.fetch && this.component.fetch.authenticate),
                    });
                    // assign after setupForm
                    Promise.all([
                        request,
                        this.root && this.root.submissionReady ? this.root.submissionReady : Promise.resolve()
                    ])
                        .then(function (data) {
                        setTimeout(function () {
                            _this.assign(data[0], flags);
                        });
                    });
                    break;
                case 'indexeddb':
                    if (!window.indexedDB) {
                        window.alert("Your browser doesn't support current version of indexedDB");
                    }
                    if (this.component.indexeddb && this.component.indexeddb.database && this.component.indexeddb.table) {
                        var request_1 = window.indexedDB.open(this.component.indexeddb.database);
                        request_1.onupgradeneeded = function (event) {
                            if (_this.component.customOptions) {
                                var db_1 = event.target.result;
                                var objectStore = db_1.createObjectStore(_this.component.indexeddb.table, { keyPath: 'myKey', autoIncrement: true });
                                objectStore.transaction.oncomplete = function () {
                                    var transaction = db_1.transaction(_this.component.indexeddb.table, 'readwrite');
                                    _this.component.customOptions.forEach(function (item) {
                                        transaction.objectStore(_this.component.indexeddb.table).put(item);
                                    });
                                };
                            }
                        };
                        request_1.onerror = function () {
                            window.alert(request_1.errorCode);
                        };
                        request_1.onsuccess = function (event) {
                            var db = event.target.result;
                            var transaction = db.transaction(_this.component.indexeddb.table, 'readwrite');
                            var objectStore = transaction.objectStore(_this.component.indexeddb.table);
                            new NativePromise(function (resolve) {
                                var responseItems = [];
                                objectStore.getAll().onsuccess = function (event) {
                                    event.target.result.forEach(function (item) {
                                        responseItems.push(item);
                                    });
                                    resolve(responseItems);
                                };
                            }).then(function (items) { return _this.assign(items, flags); });
                        };
                    }
                    break;
                case 'custom':
                    // TODO: Implement custom async code?
                    break;
            }
        }
    };
    DataSource.prototype.assign = function (data, flags) {
        if (!_.isEqual(this.dataValue, data)) {
            this.dataValue = data;
            this.triggerChange(flags && flags.fromSubmission ? { dataSourceInitialLoading: true } : null);
        }
        if (this.component.event) {
            this.emit(this.interpolate(this.component.event), this.data);
            this.events.emit(this.interpolate(this.component.event), this.data);
            this.emit('customEvent', {
                type: this.interpolate(this.component.event),
                component: this.component,
                data: this.data,
            });
        }
    };
    DataSource.prototype.validateMultiple = function () {
        // DataSource component can have both values.
        return false;
    };
    DataSource.prototype.specifyBody = function () {
        var result = null;
        try {
            result = this.evaluate(this.component.fetch.specifyPostBody, {
                value: this.dataValue,
                row: this.data,
                data: this.rootValue,
                component: this.component,
            }, 'body');
        }
        catch (e) {
            result = null;
        }
        return result;
    };
    ;
    DataSource.editForm = editForm;
    return DataSource;
}(Component));
export default DataSource;
