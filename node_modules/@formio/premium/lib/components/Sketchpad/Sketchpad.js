var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import _ from 'lodash';
import { Formio, Components } from 'formiojs';
import NativePromise from 'native-promise-only';
import Two from 'two.js';
import Picker from 'vanilla-picker';
import editForm from './Sketchpad.form';
import getModes from './Sketchpad.modes';
import toolbarButtons from './Sketchpad.toolbar.buttons';
var FieldComponent = Components.components.field;
var Sketchpad = /** @class */ (function (_super) {
    __extends(Sketchpad, _super);
    function Sketchpad() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, args) || this;
        _this.dimensionsCorrection = 1;
        _this.imageType = _this.component.imageType;
        _this.modes = getModes.call(_this, Two);
        _this.state = {
            mode: Object.keys(_this.modes)[0],
            stroke: _this.component.defaultStroke || Sketchpad.defaultStroke,
            fill: _this.component.defaultFill || Sketchpad.defaultFill,
            linewidth: _this.component.defaultLineWidth || Sketchpad.defaultLineWidth,
            circleSize: _this.component.defaultCircleSize || Sketchpad.defaultCircleSize,
        };
        _this.dimensionsMultiplier = 1;
        _this.zoomInfo = {
            viewBox: {},
            canvasViewBox: {},
            multiplier: 1.5,
            totalMultiplier: 1,
        };
        _this.deleted = [];
        _this.layers = [];
        return _this;
    }
    Object.defineProperty(Sketchpad, "defaultFill", {
        get: function () {
            return '#ccc';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad, "defaultStroke", {
        get: function () {
            return '#333';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad, "defaultLineWidth", {
        get: function () {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad, "defaultCircleSize", {
        get: function () {
            return 10;
        },
        enumerable: false,
        configurable: true
    });
    Sketchpad.schema = function () {
        var extend = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            extend[_i] = arguments[_i];
        }
        return FieldComponent.schema.apply(FieldComponent, __spreadArrays([{
                type: 'sketchpad',
                label: 'Sketchpad',
                key: 'sketchpad',
                input: true,
                modalEdit: true,
                imageType: 'image',
                autoSize: true,
                defaultZoom: 100,
                defaultStroke: Sketchpad.defaultStroke,
                defaultFill: Sketchpad.defaultFill,
                defaultLineWidth: Sketchpad.defaultLineWidth,
                defaultCircleSize: Sketchpad.defaultCircleSize,
            }], extend));
    };
    Object.defineProperty(Sketchpad, "builderInfo", {
        get: function () {
            return {
                title: 'Sketchpad',
                group: 'premium',
                icon: 'image',
                weight: 110,
                documentation: 'http://help.form.io/userguide/',
                schema: Sketchpad.schema(),
            };
        },
        enumerable: false,
        configurable: true
    });
    Sketchpad.prototype.render = function () {
        return _super.prototype.render.call(this, this.renderTemplate(this.templateName, __assign({}, this.renderContext)));
    };
    Sketchpad.prototype.loadComponentRefs = function (element) {
        this.loadRefs(element, __assign({ canvas: 'single', drawingContainer: 'single', background: 'single', backgroundImage: 'single', totalMultiplier: 'single', previewContainer: 'single', previewDrawing: 'single' }, this.buttonsRefs));
    };
    Sketchpad.prototype.attach = function (element) {
        var _this = this;
        var backgroundReadyPromise = new NativePromise(function (resolve, reject) {
            _this.backgroundReady = { resolve: resolve, reject: reject };
        });
        this.backgroundReady.promise = backgroundReadyPromise;
        var superAttach = _super.prototype.attach.call(this, element);
        this.loadComponentRefs(element);
        if (this.refs.canvas) {
            this.createDrawingArea();
            this.backgroundReady.promise.then(function () { return _this.onBackgroundReady(); });
            if (!this.disabled && !this.shouldDisabled && !this.readOnly) {
                this.attachDrawEvents();
            }
            if (this.imageType === 'image' && this.refs.backgroundImage) {
                this.loadBackgroundImage(this.refs.backgroundImage);
            }
            else {
                this.addBackground();
            }
            this.attachToolbar();
        }
        return superAttach;
    };
    Object.defineProperty(Sketchpad.prototype, "buttonsRefs", {
        get: function () {
            var refsConfig = {};
            Object.values(toolbarButtons).forEach(function (buttonsGroup) { return buttonsGroup.forEach(function (button) {
                refsConfig[button.key] = 'single';
                if (button.input) {
                    refsConfig[button.key + "-input"] = 'single';
                }
            }); });
            return refsConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "renderContext", {
        get: function () {
            return {
                zoomInfo: {
                    totalMultiplier: this.zoomInfo ? Math.round(this.zoomInfo.totalMultiplier * 100) / 100 : 1,
                },
                buttonGroups: this.buttonGroups,
                disabled: _super.prototype.disabled,
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "defaultSchema", {
        get: function () {
            return Sketchpad.schema();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "templateName", {
        get: function () {
            return 'sketchpad';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "emptyValue", {
        get: function () {
            return [];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "dataReady", {
        get: function () {
            return this.backgroundReady.promise;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "attachFunctions", {
        get: function () {
            var _this = this;
            var setColor = function (element, color, onChange) {
                var picker = new Picker(element);
                element.style.color = color;
                picker.setColor(color, true);
                picker.onChange = function (newColor) {
                    element.style.color = newColor.rgbaString;
                    onChange(newColor.rgbaString);
                };
                return element;
            };
            var attachInput = function (key, value, onChange) {
                var inputRef = _this.refs[key];
                if (inputRef) {
                    inputRef.addEventListener('change', function (e) { return onChange(e.target.value); });
                    inputRef.value = value;
                }
            };
            return {
                stroke: function (element) { return setColor(element, _this.state.stroke, function (color) { return _this.state.stroke = color; }); },
                fill: function (element) { return setColor(element, _this.state.fill, function (color) { return _this.state.fill = color; }); },
                width: function () { return attachInput('width-input', _this.state.linewidth, function (lineWidth) { return _this.state.linewidth = lineWidth; }); },
                circle: function () { return attachInput('circle-input', _this.state.circleSize, function (circleSize) { return _this.state.circleSize = circleSize; }); },
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "buttonGroups", {
        get: function () {
            return Object.entries(toolbarButtons).map(function (_a) {
                var buttons = _a[1];
                return buttons;
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sketchpad.prototype, "componentLabel", {
        get: function () {
            return "" + (this.component.hideLabel ? '' : "<label class=\"control-label\">" + this.component.label + "</label><br>");
        },
        enumerable: false,
        configurable: true
    });
    Sketchpad.prototype.loadBackgroundImage = function (backgrounImageElement) {
        var _this = this;
        backgrounImageElement.addEventListener('load', function () { return _this.addBackground(); });
        backgrounImageElement.setAttribute('src', this.component.imageUrl);
    };
    Sketchpad.prototype.createDrawingArea = function () {
        this.two = new Two({ type: Two.Types.svg }).appendTo(this.refs.canvas);
        this.canvasSvg = this.two.renderer.domElement;
        this.addClass(this.canvasSvg, 'formio-sketchpad-svg');
        this.canvasSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    };
    Sketchpad.prototype.getActualCoordinate = function (coordinate) {
        // recalculate coordinate taking into account changed size of drawing area
        var x = coordinate.x, y = coordinate.y;
        var minX = this.zoomInfo.canvasViewBox.current.minX;
        var minY = this.zoomInfo.canvasViewBox.current.minY;
        coordinate.x = Math.round(x / this.zoomInfo.totalMultiplier / this.dimensionsMultiplier + minX);
        coordinate.y = Math.round(y / this.zoomInfo.totalMultiplier / this.dimensionsMultiplier + minY);
        return coordinate;
    };
    Sketchpad.prototype.onBackgroundReady = function () {
        var _this = this;
        this.backgroundReady.isReady = true;
        this.addEventListener(window, 'resize', _.debounce(function () { return _this.stretchDrawingArea(); }, 100));
        this.resetZoom(); // set zoom to default
    };
    Sketchpad.prototype.addBackground = function () {
        var _this = this;
        if (this.refs.backgroundImage && this.refs.backgroundImage.complete) {
            this.setBackgroundImage();
        }
        else if (this.component.imageUrl && this.imageType === 'svg') {
            Formio.makeStaticRequest(this.component.imageUrl, 'GET', null, { noToken: true, headers: {} })
                .then(function (image) {
                _this.setBackgroundImage(image);
            })
                .catch(function (err) {
                /* tslint:disable */
                console.warn(err);
                /* tslint:enable */
                _this.refs.background.innerHTML = _this.t('Background image failed to load. Tagpad doesn\'t work without background image');
                _this.backgroundReady.reject();
            });
        }
    };
    Sketchpad.prototype.parseSvg = function (svgMarkup) {
        var xmlDoc = new DOMParser().parseFromString(svgMarkup, 'image/svg+xml');
        var backgroundSvg = xmlDoc.getElementsByTagName('svg');
        if (!backgroundSvg || !backgroundSvg[0]) {
            return null;
        }
        return backgroundSvg[0];
    };
    Sketchpad.prototype.prepareSvg = function (svg) {
        // make background image to be stretched to available width and preserve aspect ratio
        svg.removeAttribute('width');
        svg.removeAttribute('height');
        svg.setAttribute('ref', 'backgroundImage');
    };
    Sketchpad.prototype.setSvgImage = function (svgMarkup) {
        var backgroundSvg = this.parseSvg(svgMarkup);
        if (!backgroundSvg) {
            /* tslint:disable */
            console.warn("Sketchpad '" + this.component.key + "': Background SVG doesn't contain <svg> tag on it");
            /* tslint:enable */
            return;
        }
        // read initial dimensions from viewBox
        var initialViewBox = backgroundSvg.getAttribute('viewBox');
        var dimensions = initialViewBox ? initialViewBox.split(' ').map(parseFloat)
            : this.mapDimensionsFromAttributes(backgroundSvg);
        this.setDimensions.apply(this, dimensions);
        this.prepareSvg(backgroundSvg);
        var viewBox = this.dimensions;
        this.assignZoomInfo(viewBox);
        this.setViewBoxAttribute(backgroundSvg, viewBox);
        svgMarkup = new XMLSerializer().serializeToString(backgroundSvg);
        // fix issue in Chrome when it returned '<svg:svg>...</svg:svg>' string after serialization
        svgMarkup = svgMarkup.replace('<svg:svg', '<svg').replace('</svg:svg>', '</svg>');
        this.loadComponentRefs(this.element);
        this.refs.background.innerHTML = svgMarkup;
    };
    Sketchpad.prototype.assignZoomInfo = function (viewBox, type) {
        if (type === void 0) { type = 'viewBox'; }
        this.zoomInfo[type].default = {
            width: viewBox.width,
            height: viewBox.height,
            minX: viewBox.minX,
            minY: viewBox.minY,
        };
        this.zoomInfo[type].current = _.cloneDeep(this.zoomInfo[type].default);
    };
    Sketchpad.prototype.buttonAttributes = function (button) {
        return (button && button.input && button.input.attributes) ?
            Object.entries(button.input.attributes).map(function (_a) {
                var attr = _a[0], value = _a[1];
                return attr + "='" + value + "'";
            }).join(' ') :
            '';
    };
    Sketchpad.prototype.attachDrawEvents = function () {
        var _this = this;
        this.canvasSvg
            .addEventListener('mousedown', function (e) {
            e.preventDefault();
            var offset = _this.canvasSvg.getBoundingClientRect();
            // change cursor
            var cursor = 'default';
            if (_this.modes[_this.state.mode].cursor) {
                cursor = _this.modes[_this.state.mode].cursor.clicked || _this.modes[_this.state.mode].cursor.hover;
            }
            _this.canvasSvg.style.cursor = cursor;
            if (_this.modes[_this.state.mode].eventStart) {
                _this.modes[_this.state.mode].eventStart(_this.getActualCoordinate({
                    x: e.clientX - offset.left,
                    y: e.clientY - offset.top,
                }));
            }
            var mouseDrag = function (e) {
                e.preventDefault();
                var offset = _this.canvasSvg.getBoundingClientRect();
                if (_this.modes[_this.state.mode].drag) {
                    _this.modes[_this.state.mode].drag(_this.getActualCoordinate({
                        x: e.clientX - offset.left,
                        y: e.clientY - offset.top,
                    }));
                }
            };
            var mouseEnd = function (e) {
                e.preventDefault();
                _this.canvasSvg.removeEventListener('mousemove', mouseDrag);
                _this.canvasSvg.removeEventListener('mouseup', mouseEnd);
                document.removeEventListener('mouseup', mouseEnd);
                // change cursor
                var cursor = 'default';
                if (_this.modes[_this.state.mode].cursor) {
                    cursor = _this.modes[_this.state.mode].cursor.hover || cursor;
                }
                _this.canvasSvg.style.cursor = cursor;
                var offset = _this.canvasSvg.getBoundingClientRect();
                if (_this.modes[_this.state.mode].eventEnd) {
                    _this.modes[_this.state.mode].eventEnd(_this.getActualCoordinate({
                        x: e.clientX - offset.left,
                        y: e.clientY - offset.top,
                    }));
                }
            };
            _this.canvasSvg.addEventListener('mousemove', mouseDrag);
            _this.canvasSvg.addEventListener('mouseup', mouseEnd);
            // this is necessary to stop drawing after mouse is up outside of canvas
            document.addEventListener('mouseup', mouseEnd);
            return false;
        });
        // Set up touch events.
        this.canvasSvg
            .addEventListener('touchstart', function (e) {
            e.preventDefault();
            var offset = _this.canvasSvg.getBoundingClientRect();
            var touch = e.changedTouches[0];
            // change cursor
            var cursor = 'default';
            if (_this.modes[_this.state.mode].cursor) {
                cursor = _this.modes[_this.state.mode].cursor.clicked || _this.modes[_this.state.mode].cursor.hover;
            }
            _this.canvasSvg.style.cursor = cursor;
            if (_this.modes[_this.state.mode].eventStart) {
                _this.modes[_this.state.mode].eventStart(_this.getActualCoordinate({
                    x: touch.pageX - offset.left,
                    y: touch.pageY - offset.top,
                }));
            }
            var touchDrag = function (e) {
                e.preventDefault();
                var offset = _this.canvasSvg.getBoundingClientRect();
                var touch = e.changedTouches[0];
                if (_this.modes[_this.state.mode].drag) {
                    _this.modes[_this.state.mode].drag(_this.getActualCoordinate({
                        x: touch.pageX - offset.left,
                        y: touch.pageY - offset.top,
                    }));
                }
            };
            var touchEnd = function (e) {
                e.preventDefault();
                _this.canvasSvg
                    .removeEventListener('touchmove', touchDrag);
                _this.canvasSvg
                    .removeEventListener('touchend', touchEnd);
                var offset = _this.canvasSvg.getBoundingClientRect();
                var touch = e.changedTouches[0];
                // change cursor
                var cursor = 'default';
                if (_this.modes[_this.state.mode].cursor) {
                    cursor = _this.modes[_this.state.mode].cursor.hover || cursor;
                }
                _this.canvasSvg.style.cursor = cursor;
                if (_this.modes[_this.state.mode].eventEnd) {
                    _this.modes[_this.state.mode].eventEnd(_this.getActualCoordinate({
                        x: touch.pageX - offset.left,
                        y: touch.pageY - offset.top,
                    }));
                }
            };
            _this.canvasSvg
                .addEventListener('touchmove', touchDrag);
            _this.canvasSvg
                .addEventListener('touchend', touchEnd);
            return false;
        });
        this.two.update();
    };
    Sketchpad.prototype.attachToolbar = function () {
        this.attachModesButtons();
        this.attachStylesButtons();
        this.attachActionsButtons();
        this.setActiveButton(this.state.mode);
    };
    Sketchpad.prototype.attachModesButtons = function () {
        var _this = this;
        toolbarButtons.modes.forEach(function (mode) {
            var buttonRef = _this.refs[mode.key];
            if (buttonRef && _this.modes[mode.key]) {
                var modeConfig_1 = _this.modes[mode.key];
                buttonRef.addEventListener('click', function (e) { return _this.setState(modeConfig_1.state); });
                _this.callAttachFunction(buttonRef, mode.key);
            }
        });
    };
    Sketchpad.prototype.attachStylesButtons = function () {
        var _this = this;
        toolbarButtons.styles.forEach(function (style) {
            var buttonRef = _this.refs[style.key];
            if (buttonRef) {
                _this.callAttachFunction(buttonRef, style.key);
            }
        });
    };
    Sketchpad.prototype.attachActionsButtons = function () {
        var _this = this;
        toolbarButtons.actions.forEach(function (action) {
            var buttonRef = _this.refs[action.key];
            if (buttonRef) {
                buttonRef.addEventListener('click', function () { return _this[action.key](); });
            }
        });
    };
    Sketchpad.prototype.callAttachFunction = function (element, key) {
        if (this.attachFunctions[key]) {
            this.attachFunctions[key](element);
        }
    };
    Sketchpad.prototype.setState = function (state) {
        Object.assign(this.state, state);
        this.setActiveButton(this.state.mode);
        this.canvasSvg.style.cursor = _.get(this.modes[this.state.mode], 'cursor.hover', 'default');
    };
    Sketchpad.prototype.setActiveButton = function (mode) {
        var _this = this;
        toolbarButtons.modes.forEach(function (modeButton) {
            if (_this.refs[modeButton.key]) {
                _this.removeClass(_this.refs[modeButton.key], 'active');
            }
            if (_this.refs[mode]) {
                _this.addClass(_this.refs[mode], 'active');
            }
        });
    };
    Sketchpad.prototype.setBackgroundImage = function (image) {
        if (this.imageType === 'svg') {
            if (image && image.startsWith('<?xml')) {
                this.setSvgImage(image);
            }
            else { // Fallback to the 'image', after the image is loaded, this method will be called again
                this.imageType = 'image';
                var background = new Image();
                background.setAttribute('ref', 'backgroundImage');
                this.refs.background.appendChild(background);
                this.loadBackgroundImage(background);
            }
        }
        else {
            this.setRasterImage();
        }
        this.onBackgroundImageWasSetted();
    };
    Sketchpad.prototype.setRasterImage = function () {
        var viewBoxWidth = this.refs.backgroundImage.width;
        var viewBoxHeight = this.refs.backgroundImage.height;
        this.setDimensions(0, 0, viewBoxWidth, viewBoxHeight);
        this.assignZoomInfo(this.dimensions);
        this.assignZoomInfo(this.dimensions, 'canvasViewBox');
    };
    Sketchpad.prototype.onBackgroundImageWasSetted = function () {
        this.loadRefs(this.refs.background, {
            backgroundImage: 'single',
        });
        var width = this.component.width;
        var height = this.component.height;
        if (this.component.autoSize) {
            var calculatedSize = this.calculateAutoSize();
            width = calculatedSize.width;
            height = calculatedSize.height;
        }
        if (width && height && !this.component.autoSize) {
            this.refs.drawingContainer.style.maxWidth = width + "px";
            this.refs.drawingContainer.style.maxHeight = height + "px";
        }
        this.setDimensions(0, 0, width, height);
        this.assignZoomInfo(this.dimensions, 'canvasViewBox');
        this.dimensionsCorrection = this.dimensions.width / this.zoomInfo.viewBox.default.width;
        // set canvas image viewBox (necessary for canvas SVG to stretch properly without losing correct aspect ration)
        this.setViewBoxAttribute(this.canvasSvg, this.zoomInfo.canvasViewBox.default);
        this.setEditorSize(this.dimensions.width, this.dimensions.height);
        this.stretchDrawingArea();
        this.draw(this.dataValue);
        this.backgroundReady.resolve();
    };
    Sketchpad.prototype.calculateAutoSize = function () {
        var width = Math.round(this.refs.drawingContainer.offsetWidth);
        var currentWidth = this.dimensions.width;
        var currentHeight = this.dimensions.height;
        var ratio = currentWidth / currentHeight;
        var height = Math.round(width / ratio);
        return { width: width, height: height };
    };
    Sketchpad.prototype.setOpenModalElement = function () {
        var template = "\n      " + this.componentLabel + "\n      <div class='formio-sketchpad-modal-preview-container' ref='previewContainer'>\n        <div ref=\"openModal\">\n          <img class='formio-sketchpad-modal-preview-background' src=" + this.component.imageUrl + " width=\"100%\"/>\n          " + this.getPreviewImage() + "\n        </div>\n      </div>\n    ";
        this.componentModal.setOpenModalElement(template);
    };
    Sketchpad.prototype.getPreviewImage = function () {
        if (!this.canvasSvg || !this.two || !this.zoomInfo.viewBox.default) {
            return '';
        }
        else {
            return "<img class=\"formio-sketchpad-modal-preview-drawing\" src=\"data:image/svg+xml;base64," + this.getEncodedDrawing() + "\"\n                                  ref=\"previewDrawing\" width=\"100%\"/>";
        }
    };
    Sketchpad.prototype.getEncodedDrawing = function () {
        var svgElement = this.getSvg();
        var svg = new XMLSerializer().serializeToString(svgElement);
        var encoded = window.btoa(svg);
        return encoded;
    };
    Sketchpad.prototype.getModalPreviewTemplate = function () {
        var template = "\n      " + this.componentLabel + "\n      <div class='formio-sketchpad-modal-preview-container' ref='previewContainer'>\n        <div ref=\"openModal\">\n          <img class='formio-sketchpad-modal-preview-background' src=" + this.component.imageUrl + " width=\"100%\"/>\n          " + this.getPreviewImage() + "\n        </div>\n      </div>";
        return template;
    };
    Sketchpad.prototype.mapDimensionsFromAttributes = function (svg) {
        return [
            { attribute: 'x', defaultValue: 0 },
            { attribute: 'y', defaultValue: 0 },
            { attribute: 'width', defaultValue: 640 },
            { attribute: 'height', defaultValue: 480 },
        ].map(function (dimension) {
            return parseFloat(svg.getAttribute(dimension.attribute)) || dimension.defaultValue;
        });
    };
    Sketchpad.prototype.setDimensions = function (viewBoxMinX, viewBoxMinY, viewBoxWidth, viewBoxHeight) {
        this.dimensions = {
            width: viewBoxWidth,
            height: viewBoxHeight,
            minX: viewBoxMinX,
            minY: viewBoxMinY,
        };
    };
    Sketchpad.prototype.stretchDrawingArea = function () {
        var style = window.getComputedStyle(this.refs.drawingContainer);
        var width = style ? Math.round(Number.parseFloat(style.getPropertyValue('width'))) : undefined;
        var height = style ? Math.round(Number.parseFloat(style.getPropertyValue('height'))) : undefined;
        // don't stretch if background dimensions are unknown yet
        if (width && height) {
            var _a = this.zoomInfo, canvasViewBox = _a.canvasViewBox, totalMultiplier = _a.totalMultiplier;
            var defaultWidth = canvasViewBox.default.width;
            var defaultHeight = canvasViewBox.default.height;
            this.dimensionsMultiplier = width / defaultWidth;
            this.dimensions.width = Math.round(defaultWidth * this.dimensionsMultiplier);
            this.dimensions.height = Math.round(defaultHeight * this.dimensionsMultiplier);
            if (width === this.editorSize.width && height === this.editorSize.height) {
                return;
            }
            var editorWidth = totalMultiplier > 1 ? this.dimensions.width : this.dimensions.width * totalMultiplier;
            var editorHeight = totalMultiplier > 1 ? this.dimensions.height : this.dimensions.height * totalMultiplier;
            this.setEditorSize(editorWidth, editorHeight);
        }
    };
    Sketchpad.prototype.setEditorSize = function (width, height) {
        this.editorSize = ({ width: width, height: height });
        this.two.width = width;
        this.two.height = height;
        this.two.update();
        this.refs.backgroundImage.setAttribute('width', width);
        this.refs.backgroundImage.setAttribute('height', height);
        this.canvasSvg.style.width = width;
        this.canvasSvg.style.height = height;
    };
    Sketchpad.prototype.clear = function () {
        if (this.two) {
            this.two.clear();
        }
    };
    Sketchpad.prototype.clearAll = function () {
        this.layers = [];
        this.dataValue = [];
        if (this.two) {
            this.clear();
            this.two.update();
        }
    };
    Sketchpad.prototype.draw = function (value) {
        var _this = this;
        if (!this.two) {
            return;
        }
        this.clear();
        if (!value || !value.length) {
            this.two.update();
            return;
        }
        this.layers = value.map(function (item) { return _this.modes[item.mode].draw(item); });
        this.two.update();
        this.appendDrawingToPreview();
    };
    Sketchpad.prototype.appendDrawingToPreview = function () {
        if (this.componentModal && this.componentModal.element) {
            this.loadComponentRefs(this.componentModal.element);
            var drawingData = "data:image/svg+xml;base64," + this.getEncodedDrawing();
            if (this.refs.previewDrawing) {
                this.refs.previewDrawing.setAttribute('src', drawingData);
            }
            else {
                var drawing = new Image();
                drawing.src = drawingData;
                this.addClass(drawing, 'formio-sketchpad-modal-preview-drawing');
                drawing.setAttribute('ref', 'previewDrawing');
                if (this.refs.previewContainer) {
                    this.refs.previewContainer.appendChild(drawing);
                }
            }
        }
    };
    Sketchpad.prototype.undo = function () {
        var value = this.dataValue.slice();
        if (!value.length) {
            return;
        }
        this.deleted.push(value.pop());
        this.dataValue = value;
        this.triggerChange();
        this.draw(value);
    };
    Sketchpad.prototype.redo = function () {
        if (!this.deleted.length) {
            return;
        }
        var value = this.dataValue.slice();
        value.push(this.deleted.pop());
        this.dataValue = value;
        this.triggerChange();
        this.draw(value);
    };
    Sketchpad.prototype.setValue = function (value, flags) {
        if (!this.backgroundReady.isReady || !this.two) {
            return;
        }
        _super.prototype.setValue.call(this, value, flags);
        this.draw(value);
    };
    Sketchpad.prototype.getSvg = function () {
        // clone view SVG element from editor
        var svgElement = this.canvasSvg.cloneNode(true);
        this.addClass(svgElement, 'formio-sketchpad-preview-svg');
        svgElement.removeAttribute('style');
        // set viewBox to default to reset zoom
        var defaultViewBox = this.zoomInfo.canvasViewBox.default;
        this.setViewBoxAttribute(svgElement, defaultViewBox);
        return svgElement;
    };
    Sketchpad.prototype.normalizeSvgOffset = function (type) {
        if (type === void 0) { type = 'viewBox'; }
        var viewBox = this.zoomInfo[type];
        // don't let offset go out of SVG on the left and on the top
        this.zoomInfo[type].current.minX = viewBox.current.minX < viewBox.default.minX ? viewBox.default.minX
            : viewBox.current.minX;
        this.zoomInfo[type].current.minY = viewBox.current.minY < viewBox.default.minY ? viewBox.default.minY
            : viewBox.current.minY;
        // don't let offset go out of SVG on the right and on the bottom
        var canvasMaxOffsetX = viewBox.default.width - viewBox.current.width + viewBox.default.minX;
        var canvasMaxOffsetY = viewBox.default.height - viewBox.current.height + viewBox.default.minY;
        this.zoomInfo[type].current.minX = viewBox.current.minX > (canvasMaxOffsetX) ? canvasMaxOffsetX
            : viewBox.current.minX;
        this.zoomInfo[type].current.minY = viewBox.current.minY > (canvasMaxOffsetY) ? canvasMaxOffsetY
            : viewBox.current.minY;
    };
    Sketchpad.prototype.setViewBoxAttribute = function (element, viewBox) {
        element.setAttribute('viewBox', viewBox.minX + " " + viewBox.minY + " " + viewBox.width + " " + viewBox.height);
    };
    Sketchpad.prototype.updateSvgViewBox = function (type) {
        if (type === void 0) { type = 'viewBox'; }
        // set viewBox so that SVG gets zoomed to the proper area according to zoomInfo
        var viewBox = this.zoomInfo[type].current;
        if (this.imageType !== 'svg') {
            return;
        }
        if (type === 'viewBox') {
            this.setViewBoxAttribute(this.refs.backgroundImage, viewBox);
        }
        else {
            this.setViewBoxAttribute(this.canvasSvg, viewBox);
        }
    };
    Sketchpad.prototype.drag = function (offset, type) {
        if (type === void 0) { type = 'viewBox'; }
        // calculate new offsets for SVG
        this.zoomInfo[type].current.minX = this.zoomInfo[type].current.minX - offset.x;
        this.zoomInfo[type].current.minY = this.zoomInfo[type].current.minY - offset.y;
        this.normalizeSvgOffset(type);
        this.updateSvgViewBox(type);
    };
    Sketchpad.prototype.dragImage = function (offset) {
        var correctedOffset = this.dimensionsCorrection ? {
            x: offset.x / this.dimensionsCorrection,
            y: offset.y / this.dimensionsCorrection
        } : offset;
        this.drag(correctedOffset);
        this.drag(offset, 'canvasViewBox');
    };
    Sketchpad.prototype.setTotalMultiplier = function (multiplier) {
        this.zoomInfo.totalMultiplier = multiplier;
        this.refs.totalMultiplier.innerHTML = this.t(Math.round(multiplier * 100) / 100);
    };
    Sketchpad.prototype.zoomImage = function (coordinate, type) {
        if (type === void 0) { type = 'viewBox'; }
        // calculate new viewBox width for canvas
        this.zoomInfo[type].current.width =
            Math.round(this.zoomInfo[type].default.width / this.zoomInfo.totalMultiplier);
        this.zoomInfo[type].current.height =
            Math.round(this.zoomInfo[type].default.height / this.zoomInfo.totalMultiplier);
        var _a = this.zoomInfo[type].current, currentWidth = _a.width, currentHeight = _a.height;
        var _b = this.zoomInfo[type].default, defaultWidth = _b.width, defaultHeight = _b.height;
        if (currentWidth > defaultWidth && currentHeight > defaultHeight) {
            this.zoomOut(type); // if should get less than initial size, change editor size instead of viewBox size
        }
        else {
            this.zoomIn(coordinate, type); // if should get more than initial size, change viewBox size
        }
        this.updateSvgViewBox(type);
    };
    Sketchpad.prototype.zoom = function (coordinate, multiplier) {
        this.setTotalMultiplier(this.zoomInfo.totalMultiplier * multiplier);
        var correctedCoordinate = this.dimensionsCorrection ? {
            x: coordinate.x / this.dimensionsCorrection,
            y: coordinate.y / this.dimensionsCorrection
        } : coordinate;
        this.zoomImage(correctedCoordinate);
        this.zoomImage(coordinate, 'canvasViewBox');
    };
    Sketchpad.prototype.zoomOut = function (type) {
        if (type === void 0) { type = 'viewBox'; }
        this.setEditorSize(this.dimensions.width * this.zoomInfo.totalMultiplier, this.dimensions.height * this.zoomInfo.totalMultiplier);
        // restore default viewBox values for canvas and background
        this.zoomInfo[type].current = _.cloneDeep(this.zoomInfo[type].default);
    };
    Sketchpad.prototype.zoomIn = function (coordinate, type) {
        if (type === void 0) { type = 'viewBox'; }
        // restore editor size if needed
        if (this.canvasSvg.width !== this.dimensions.width || this.canvasSvg.height !== this.dimensions.height) {
            this.setEditorSize(this.dimensions.width, this.dimensions.height);
        }
        // if backgound is simple image change the editor's size
        if (this.imageType !== 'svg') {
            if (this.refs.backgroundImage) {
                this.setEditorSize(this.dimensions.width * this.zoomInfo.totalMultiplier, this.dimensions.height * this.zoomInfo.totalMultiplier);
            }
        }
        else {
            this.zoomInfo[type].current.minX = coordinate.x - this.zoomInfo[type].current.width / 2;
            this.zoomInfo[type].current.minY = coordinate.y - this.zoomInfo[type].current.height / 2;
        }
        this.normalizeSvgOffset(type);
    };
    Sketchpad.prototype.resetZoom = function () {
        this.zoom({ x: 0, y: 0 }, (this.component.defaultZoom / 100) / this.zoomInfo.totalMultiplier);
    };
    Sketchpad.editForm = editForm;
    return Sketchpad;
}(FieldComponent));
export default Sketchpad;
